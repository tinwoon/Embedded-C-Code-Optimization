# Embedded-C-Code-Optimization
#### 임베디드 시스템 개발 환경

- 네이티브 개발환경

  > 개발하는 시스템의 프로세서와 프로그램이 실행될 시스템의 츠로세서가 같은 개발환경

- 크로스 컴파일 개발환경

  > - 임베디드 소프트웨어 개발환경은 개발하는 시스템의 프로세서와 실행될 시스템의 프로세서가 같지 않은 환경
  >
  > - 생성되는 개발 환경을 다른 컴파일러를 사용해야 한다는 뜻이 된다.
  > - 즉 임베디드 소프트웨어를 개발하려면 다른 프로세서용 기계코드를 생성해주는 컴파일러가 필요하며 이를 크로스 컴파일러라 한다. (arm-linux-gcc, ADC 등)
  > - 크로스 컴파일러, 크로스 어셈블러, 링커/로케이터 등으로 구성된 소프트웨어 개발도구를 "툴체인"이라 한다.

- 입출력 장치 제어 방법

  - 입출력 장치 제어 방법에는 두가지 방법이 있다.

  > - 메모리 맵I/O7
  >
  >   => 입출력 장치들이 사용하는 메모리가 따로 정해져 있지 않아서 장치가 사용할 메모리를 개발자가 직접 지정하여 사용하는 방법
  >
  > - I/O 맵 방법
  >
  >   => I/O는 입출력 장치들이 사용하는 메모리가 미리 정해져 있어서 지정된 메모리를 사용하는 방법

- 하드웨어 제어 동작 예시

  > LED 3000_0000번지의 5,6,7번 비트에 값을 쓰는 방법은 다음과 같다.
  >
  > ```c
  > char *p = (char*)0x30000000;
  > //5,6,7번 비트를 1로 set
  > *p |= (0x1<<5) + (0x1<<6) + (0x1<<7);
  > //5,6,7번 비트를 0으로 set
  > *p &= ~((0x1<<5) + (0x1<<6) + (0x1<<7));
  > //특정 비트 반전
  > *p &^= 0x1<<5;
  > ```

- 비트 연산을 통한 활용

  > 어떤 수에 대한 값을 더했을 때 가장 가까운 4의 배수에 해당하는 수를 만드려면 어떻게 해야하는가
  >
  > - 그냥 C code
  >
  >   ```c
  >   start = 100;
  >   scanf("%d", &x);
  >   start += x;
  >   if((start % 4) == 1)
  >       start += 3;
  >   else if ((start % 4) == 2)
  >       start += 2;
  >   else if((start % 4) == 3)
  >       start += 1;
  >   ```
  >
  > - 비트 연산을 사용한 C code
  >
  >   ```c
  >   start = 100;
  >   scanf("%d", &x);
  >   start += x;
  >   start += 0x3; //1에서 3을 더해도, 2에서 3을 더해도, 3에서 3을 더해도, 4에서 3을 더해도 
  >   				// 0bxxxxx...1xx 형태에 해당하는 비트 값을 가진다.
  >   start &= ~(0x3); // 0bxxxxx.....1xx & 0bxxxxxxx...100 의 값은 0b100이 되기에 4의 배수에 해당하는 값이 된다.
  >   ```

- 비트 연산을 활용한 매크로 정리

  > - 한 비트 클리어(예> 5번 비트)
  >
  >   `a &= ~(0x1<<5);`
  >
  > - 연속된 여러 비트 클리어(예> 5,4,3,번 비트)
  >
  >   `a &= ~(0x7<<3);`
  >
  > - 떨어져 있는 여러 비트 클리어 (예> 5,3,2번 비트)
  >
  >   `a &= ~((0x1<<5) + (0x3<<2));`
  >
  > 
  >
  > - 한 비트 설정(예> 5번 비트) 
  >
  >   `a |= (0x1<<5); `
  >
  > - 연속된 여러 비트 설정 (예> 5, 4, 3번 비트) 
  >
  >   `a |= (0x7<<3);`
  >
  > - 떨어져 있는 여러 비트 설정 (예> 5,3,2번 비트)
  >
  >   `a |= (0x1<<5) + (0x3<<2);`
  >
  > 
  >
  > - 한 비트 반전
  >
  >   `a ^= (0x1<<5);`
  >
  > - 연속된 여러 비트 반전
  >
  >   `a ^= (0x7<<3);`
  >
  > - 떨어져 있는 여러 비트 반전 (예> 5, 4, 3번 비트) 
  >
  >   `a ^= (0x1<<5) + (0x3<<2);`
  >
  >   
  >
  > - 비트 검사 (예> 5번 비트)
  >
  >   `a & (0x1 <<5);`
  >
  >   
  >
  > - 비트 추출 (예 > 6, 5, 4번 비트)
  >
  >   `b = (a>>4) & 0x7;`
  
- 비트 연산은 보통 매크로를 통해 구현하는 것이 가장 좋은 방식이다. (매크로의 경우 가로를 쳐야만 개발자가 의도한 코드 대로 동작된다.)

  ```c
  //한 비트 클리어
  #define clear_bit(data, loc) ((data) &= ~(0x1<<(loc)))
  //연속된 여러 비트 클리어
  #define clear_bits(data, area, loc) ((data) &= ~((area)<<(loc)))
  
  //한 비트 설정
  #define set_bit(data, loc) ((data) |= (0x1<<loc)))
  
  //한 비트 반전
  #define invert_bit(data, loc) ((data) ^= (0x1<<(loc)))
  ```

  

- 임베디드 환경에서는 메모리 직접 접근이 가능하다. 아래와 같은 방식이 포인터 배열을 선언해서 할당 한 뒤 매번 접근하는 것 보다 빠르게 활성화 할 수 있다.

  ```c
  //LED의 주소 값이 0x30000000이며 해당 주소에 100을 넣으려면
  *(volatile unsigned int*)0x30000000 = 100;
  //과 같이 정의할 수 있다. 하지만 근본적으로 매번 이렇게 접근할 수 없으므로 보통은 아래와 같이 전처리기를 사용한다.
  
  #define PA *(volatile unsigned int*)0x30000000 = 100
  
  void init(void){
      PA |= (0x7 << 5);
  }
  ```

   

- 임베디드 환경에서는 Switch를 기반으로한 코드는 메모리 접근 내역에서 좋지 않다. 따라서 다음과 같이 정의해 주는 것이 좋다.

  - 임베디드 시스템에서 사용되는 메모리는 HDD 없이 ROM, RAM으로 구성되어 있어서 실행코드를 최소화하거나, 작업 공간을 최소화하는 방법으로 효율적으로 사용해야 한다.

  ```c
  //올바르지 않은 예
  void display(int digit){
      switch(digit){
          case 1:
              PA &= ~(0x1 << 5);
             	break;
          case 2 :
              PA &= ~(0x2 << 5);
              break;
      }
  }
  ```

  

  ```c
  void display(int digit){
      //들어온 이진수의 일의 자리가 1이면 LED3을 ON 아니면 Off
      (digit & 0x1) ? (PA &= ~(0x1 << 5) ) : (PA |= (0x1 << 5) );
      //들어온 이진수의 십의 자리가 1이면 LED2를 ON 아니면 Off
      (digit & 0x2) ? (PA &= ~(0x1 << 6) ) : (PA |= (0x1 << 6) );
      //들어온 이진수의 백의 자리가 1이면 LED1를 ON 아니면 Off
      (digit & 0x4) ? (PA &= ~(0x1 << 7) ) : (PA |= (0x1 << 7) );
  }
  ```



- `volatile`의 기능적 의미는 캐시사용안함(no-cache)이다. 

  > 보통 프로그램이 실행될 때 속도를 위해 필요한 데이터를 메모리에서 직접 읽어오지 않고 캐시로부터 읽어온다. 하지만, 하드웨어에 의해서 변경되는 값들은 캐시에 즉각적으로 반영되지 않으므로 데이터를 캐시로부터 읽어오지 말고 주 메모리에서 직접 읽어오도록 해야한다. 이러한 특성 때문에 하드웨어가 사용하는 메모리는 volatile로 선언해야 하드웨어에 의해 변경된 값들이 프로그램에 제대로 반영된다.
  >
  > 
  >
  > - 추가적으로 volatile은 캐시를 사용하지 않는 특성 외에 컴파일러 최적화가 임의로 코드를 변경하는 것을 막을 수 있기 때문이다.

- `volatile`의 추가적인 기능은 컴파일러가 main에서 호출되지 않는 함수나 delay를 위한 BusyWaiting 코드의 생략을 막을 수 있다.

  ```c
  int time;
  
  //하드웨어에 의해 호출되고 메인에는 없는 코드
  void interrupt_handler(void){
      time++;
  }
  
  //비프음이 들리지 않는다. 
  //왜냐하면 컴파일러 입장에서 main에는 호출될 일 없는 interrupt_handler 함수는 최적화 대상이기 때문에 삭제시킨다.
  //따라서 int time;을 volatile int time;으로 선언해야 개선이 가능하다.
  //또한 busy waiting을 통해 1초를 기다리는 for문 역시도 컴파일러 입장에서는 연산만하고 내부가 아무것도 수행되지 않는 문이므로 초기화 대상이다.
  //따라서 volatile int j = 0;으로 선언해야 원하는 데로 수행된다.
  void main(){
      time = 0;
      int j = 0;
      while(1){
          if((time%10) == 0 && time != 0) beep();
          for(j = 0; j < 100000; j++);
      }
  }
  ```

  
